const dataService = require('../services/dataService');
const { v4: uuidv4 } = require('uuid');

const getDrivers = async (req, res) => {
    try {
        const drivers = await dataService.getDrivers();
        const mappedDrivers = drivers.map(d => ({
            ...d,
            vehicleNumber: d.vehicle_number,
            paymentPreference: d.payment_preference
        }));
        res.json(mappedDrivers);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

const createDriver = async (req, res) => {
    try {
        const { name, vehicleNumber, paymentPreference } = req.body;
        
        if (!name || !paymentPreference || !vehicleNumber) {
            return res.status(400).json({ message: "Name, Vehicle Number, and Payment Preference are required" });
        }

        // Removed duplicate vehicle check to allow multiple drivers for the same vehicle
        
        const newDriver = {
            // id is generated by Supabase default or we can pass it. 
            // Let's rely on Supabase default or pass uuid if needed. 
            // Schema says default uuid_generate_v4(), so we don't strictly need to pass ID.
            // But to keep it consistent with previous logic, we can pass it or let DB handle it.
            // Let's pass it to be safe with current frontend expectations if any.
            // Actually, better to let DB handle ID generation if possible, but for now let's stick to explicit ID to match previous behavior exactly unless schema forbids.
            // Schema has default, but we can override.
            id: uuidv4(), 
            name,
            vehicle_number: vehicleNumber, // Map camelCase to snake_case for DB
            payment_preference: paymentPreference, // Map camelCase to snake_case for DB
            // created_at is handled by DB default
        };

        const savedDriver = await dataService.saveDriver(newDriver);
        
        // Map back to camelCase for frontend response if needed, or frontend adapts.
        // For now, let's return what DB returns. Frontend might need adjustment if it expects camelCase.
        // To minimize frontend breakage, let's map it back or ensure frontend handles snake_case.
        // The previous local store used camelCase. Supabase uses snake_case columns.
        // We should probably map it to maintain backward compatibility.
        
        const responseDriver = {
            ...savedDriver,
            vehicleNumber: savedDriver.vehicle_number,
            paymentPreference: savedDriver.payment_preference
        };

        res.status(201).json(responseDriver);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

const updateDriverPreference = async (req, res) => {
    try {
        const { id } = req.params;
        const { paymentPreference } = req.body;

        if (!paymentPreference) {
            return res.status(400).json({ message: "Payment Preference is required" });
        }

        // We can update directly
        const updated = await dataService.updateDriver({
            id,
            payment_preference: paymentPreference
        });

        if (!updated) {
             return res.status(404).json({ message: "Driver not found" });
        }

        const responseDriver = {
            ...updated,
            vehicleNumber: updated.vehicle_number,
            paymentPreference: updated.payment_preference
        };

        res.json(responseDriver);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

const deleteDriver = async (req, res) => {
    try {
        const { id } = req.params;
        const deleted = await dataService.deleteDriver(id);

        if (!deleted) {
            return res.status(404).json({ message: "Driver not found" });
        }

        res.json({ message: "Driver deleted successfully" });
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
};

module.exports = {
    getDrivers,
    createDriver,
    updateDriverPreference,
    deleteDriver
};
